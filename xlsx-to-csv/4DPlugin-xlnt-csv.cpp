/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-xlnt-csv.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : xlnt-csv
 #	author : miyako
 #	2020/10/02
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-xlnt-csv.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- xlnt-csv
                
            case 1 :
				convert_xlsx_to_csv_v2(params);
                break;
            case 2 :
                get_xlsx_sheets(params);
                break;
                
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

#if VERSIONMAC
typedef std::string  xlint_filepath_t;
#else
typedef std::wstring xlint_filepath_t;
#endif

typedef std::string  xlint_password_t;

#pragma mark -

static void get_xlnt_path(C_TEXT& path, xlint_filepath_t& xlnt_path) {
    
#if VERSIONMAC
    CUTF8String _path;
    path.copyPath(&_path);
    xlnt_path = std::string ((const char    *)_path.c_str(), _path.length());
#else
    xlnt_path = std::wstring((const wchar_t *)path.getUTF16StringPtr(), path.getUTF16Length());
#endif
}

static void get_xlnt_password(C_TEXT& password, xlint_password_t& xlnt_password) {
    
    CUTF8String _password;
    password.copyUTF8String(&_password);
    xlnt_password = std::string((const char *)_password.c_str(), _password.length());
    
}

#pragma mark -

static xlnt::workbook *open_xlsx(xlint_filepath_t& xlnt_path, xlint_password_t& xlnt_password) {
     
	xlnt::workbook *wb = new xlnt::workbook;

	try
	{
		if (xlnt_password.length())
		{
			wb->load(xlnt_path, xlnt_password);
		}
		else
		{
			wb->load(xlnt_path);
		}
	}
	catch (...)
	{

	}

	return wb;
}

#if VERSIONWIN
static xlnt::workbook *getFmIn(std::wstring& caller_event_name, std::wstring& callee_event_name) {
    
	xlnt::workbook*wb = NULL;

	DWORD len = (sizeof(DWORD) * 4);

	HANDLE fmIn = CreateFileMapping(
		INVALID_HANDLE_VALUE,
		NULL,
		PAGE_READWRITE,
		0, len,
		L"XLNT_CSV_PARAM_IN");

	BOOL success = FALSE;

	DWORD paramlen1;
	DWORD paramlen2;
    DWORD paramlen3;
    DWORD paramlen4;

	xlint_filepath_t xlnt_path;
	xlint_password_t xlnt_password;

	if (fmIn)
	{
		LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
		if (bufIn)
		{
			unsigned char *p = (unsigned char *)bufIn;
			try
			{
				CopyMemory(&paramlen1, p, sizeof(DWORD));
				p += sizeof(DWORD);
				CopyMemory(&paramlen2, p, sizeof(DWORD));
				p += sizeof(DWORD);
                CopyMemory(&paramlen3, p, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(&paramlen4, p, sizeof(DWORD));
                p += sizeof(DWORD);

				std::vector<uint8_t>param1(paramlen1);
				std::vector<uint8_t>param2(paramlen2);
                std::vector<uint8_t>param3(paramlen3);
                std::vector<uint8_t>param4(paramlen4);

				if (paramlen1)
				{
					CopyMemory(&param1[0], p, paramlen1);
					p += paramlen1;
					xlnt_path = std::wstring((const wchar_t *)&param1[0], paramlen1 / sizeof(wchar_t));
				}

				if (paramlen2)
				{
					CopyMemory(&param2[0], p, paramlen2);
					p += paramlen2;
					xlnt_password = ((const char *)&param2[0], paramlen2 / sizeof(char));
				}
                
                if (paramlen3)
                {
                    CopyMemory(&param3[0], p, paramlen3);
                    p += paramlen3;
                    caller_event_name = std::wstring((const wchar_t *)&param3[0], paramlen3 / sizeof(wchar_t));
                }
                
                if (paramlen4)
                {
                    CopyMemory(&param4[0], p, paramlen4);
                    p += paramlen4;
                    callee_event_name = std::wstring((const wchar_t *)&param4[0], paramlen4 / sizeof(wchar_t));
                }
                
				success = TRUE;
			}
			catch (...)
			{

			}
			UnmapViewOfFile(bufIn);
		}

		CloseHandle(fmIn);
	}

	if (success)
	{
		wb = open_xlsx(xlnt_path, xlnt_password);
	}

	return wb;
}

static xlnt::workbook *getFmOut() {
    
    xlnt::workbook *wb = NULL;
    
    DWORD len = sizeof(xlnt::workbook *);
    
    HANDLE fmOut = CreateFileMapping(
    INVALID_HANDLE_VALUE,
    NULL,
    PAGE_READWRITE,
    0, len,
    L"XLNT_CSV_PARAM_OUT");
    if (fmOut)
    {
        LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_READ, 0, 0, len);
        if (bufOut)
        {
            unsigned char *p = (unsigned char *)bufOut;
            try
            {
                //CopyMemory(wb, p, sizeof(xlnt::workbook *));
            }
            catch (...)
            {
                
            }
            UnmapViewOfFile(bufOut);
        }
        CloseHandle(fmOut);
    }
    
    return wb;
}

static HANDLE createFmIn(xlint_filepath_t& xlnt_path,
                         xlint_password_t& xlnt_password,
                         std::wstring& caller_event_name,
                         std::wstring& callee_event_name) {

    DWORD paramlen1 = xlnt_path.length() * sizeof(wchar_t);
    DWORD paramlen2 = xlnt_password.length() * sizeof(char);
    DWORD paramlen3 = caller_event_name.length() * sizeof(wchar_t);
    DWORD paramlen4 = callee_event_name.length() * sizeof(wchar_t);
    
    DWORD len = (sizeof(DWORD) * 4);

    len += paramlen1;
    len += paramlen2;
    len += paramlen3;
    len += paramlen4;
    
    HANDLE fmIn = CreateFileMapping(
        INVALID_HANDLE_VALUE,
        NULL,
        PAGE_READWRITE,
        0, len,
        L"XLNT_CSV_PARAM_IN");

    BOOL success = FALSE;

    if (fmIn)
    {
        LPVOID bufIn = MapViewOfFile(fmIn,
            FILE_MAP_WRITE,
            0,
            0, len);
        if (bufIn)
        {
            try
            {
                unsigned char *p = (unsigned char *)bufIn;

                CopyMemory(p, &paramlen1, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(p, &paramlen2, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(p, &paramlen3, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(p, &paramlen4, sizeof(DWORD));
                p += sizeof(DWORD);

                CopyMemory(p, xlnt_path.c_str(), paramlen1);
                p += paramlen1;
                CopyMemory(p, xlnt_password.c_str(), paramlen2);
                p += paramlen2;
                CopyMemory(p, caller_event_name.c_str(), paramlen3);
                p += paramlen3;
                CopyMemory(p, callee_event_name.c_str(), paramlen4);
                p += paramlen4;
                
                success = TRUE;
            }
            catch (...)
            {
                /* CopyMemory() failed */
            }
            UnmapViewOfFile(bufIn);
        }//bufIn
        if (!success)
        {
            CloseHandle(fmIn);
            return 0;
        }
    }

    return fmIn;
}

static HANDLE createFmOut(xlnt::workbook *wb) {

	DWORD len = sizeof(xlnt::workbook *);
	HANDLE fmOut = CreateFileMapping(
		INVALID_HANDLE_VALUE,
		NULL,
		PAGE_READWRITE,
		0, len,
		L"XLNT_CSV_PARAM_OUT");

	if (fmOut)
	{
		LPVOID bufOut = MapViewOfFile(fmOut, FILE_MAP_WRITE, 0, 0, len);
		if (bufOut)
		{
			unsigned char *p = (unsigned char *)bufOut;
			try
			{
				//CopyMemory(p, wb, sizeof(xlnt::workbook *));
				//p += sizeof(xlnt::workbook *);
			}
			catch (...)
			{

			}
			UnmapViewOfFile(bufOut);
		}//bufOut

	}

	return fmOut;
}

static HANDLE open_event_from_callee(std::wstring& name) {

	HANDLE event_p = OpenEvent(EVENT_ALL_ACCESS, FALSE, name.c_str());

	return event_p;
}

static HANDLE open_event_from_caller(std::wstring& name) {

    HANDLE event_p = OpenEvent(EVENT_ALL_ACCESS, FALSE, name.c_str());

	return event_p;
}

static HANDLE create_event_for_callee(std::wstring& name) {

	HANDLE event_p = CreateEvent(NULL, TRUE, FALSE, name.c_str());

	return event_p;
}

static HANDLE create_event_for_caller(std::wstring& name) {

	HANDLE event_p = CreateEvent(NULL, TRUE, FALSE, name.c_str());

	return event_p;
}

unsigned __stdcall open_xlsx_in_thread(void *p) {

    std::wstring caller_event_name;
    std::wstring callee_event_name;
            
	xlnt::workbook *wb = getFmIn(caller_event_name, callee_event_name);

	if (wb) {
	}

	HANDLE fmOut = createFmOut(wb);

	if (fmOut)
	{
		/* tell p that the response is ready */
		
		HANDLE event_s = open_event_from_caller(caller_event_name);

		if (event_s)
		{
			SetEvent(event_s);
			CloseHandle(event_s);
		}

		//do stuff here

		HANDLE event_c = create_event_for_callee(callee_event_name);

		/* wait for p to set scanEvent_c */
		WaitForSingleObject(event_c, INFINITE);
		ResetEvent(event_c);
		/* now ready to die */

		CloseHandle(fmOut);
	}//fmOut

	_endthreadex(0);
	return 0;
}

static xlnt::workbook *waitForEvent(HANDLE h, HANDLE event_p, std::wstring& callee_event_name) {

    xlnt::workbook *wb = NULL;
    
	BOOL exit = FALSE;

	do {
		switch (WaitForSingleObject(event_p, 100))
		{
		case WAIT_ABANDONED:
		case WAIT_FAILED:
			exit = TRUE;
			break;
		case WAIT_TIMEOUT:
			PA_YieldAbsolute();
			break;
		case WAIT_OBJECT_0:
			ResetEvent(event_p);
			BOOL success = FALSE;
       
            wb = getFmOut();

			HANDLE event_c = open_event_from_callee(callee_event_name);

			if (event_c)
			{
				/* tell c to die */
				SetEvent(event_c);
				CloseHandle(event_c);
			}

			do {
				switch (WaitForSingleObject(h, 100))
				{
				case WAIT_TIMEOUT:
					PA_YieldAbsolute();
					break;
				case WAIT_ABANDONED:
				case WAIT_FAILED:
				case WAIT_OBJECT_0:
					exit = TRUE;
					break;
				}
			} while (!exit);

			exit = TRUE;
			break;
		}

	} while (!exit);
    
    return wb;
}
#endif

void get_xlsx_sheets(PA_PluginParameters params) {
    
    /*
     get xlsx sheets(&T;&Y;&T)
     */
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_path;
    ARRAY_TEXT Param2_sheets;
    C_TEXT Param3_password;
    
    Param1_path.fromParamAtIndex(pParams, 1);
    Param2_sheets.setSize(1);
    Param3_password.fromParamAtIndex(pParams, 3);

    xlint_filepath_t xlnt_path;
    xlint_password_t xlnt_password;
    
	get_xlnt_path(Param1_path, xlnt_path);
	get_xlnt_password(Param3_password, xlnt_password);
    
#if VERSIONWIN
	CUTF8String _path;
	Param1_path.copyPath(&_path);
	xlsxioreader xlsxioread = xlsxioread_open((const char *)_path.c_str());
#else
	xlsxioreader xlsxioread = xlsxioread_open(xlnt_path.c_str());
#endif
    
    if (xlsxioread) {
        xlsxioreadersheetlist sheetlist = xlsxioread_sheetlist_open(xlsxioread);
        if (sheetlist) {
            const char *sheetname;
            while ((sheetname = xlsxioread_sheetlist_next(sheetlist)) != NULL) {
                Param2_sheets.appendUTF8String((const uint8_t *)sheetname, (uint32_t)strlen(sheetname));
            }
            xlsxioread_sheetlist_close(sheetlist);
        }
        xlsxioread_close(xlsxioread);
    }
    
    Param2_sheets.toParamAtIndex(pParams, 2);

}

#if VERSIONMAC
#define CPathString CUTF8String
#define CPathOpen fopen
#define CPathAppend "ab"
#define CPathCreate "wb"
#define CPathRead "rb"
#else
#include <Shlobj.h>
#define CPathString CUTF16String
#define CPathOpen _wfopen
#define CPathAppend L"ab"
#define CPathCreate L"wb"
#define CPathRead L"rb"
#endif

#if VERSIONMAC
typedef std::string absolute_path_t;
#define folder_separator '/'
#else
typedef std::wstring absolute_path_t;
#define folder_separator L'\\'
#endif

#if VERSIONMAC
typedef char path_t;
#else
typedef wchar_t path_t;
#endif

bool create_folder(path_t *absolute_path) {
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
    
    return success;
}

void create_parent_folder(path_t *absolute_path) {
    
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder((path_t *)folderPath.c_str());
    [filePath release];
#else
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder((path_t *)folderPath.c_str());
#endif
}

static FILE *create_csv(xlint_filepath_t file_path) {
    return CPathOpen (file_path.c_str(), CPathCreate);
}

static void generate_uuid_pair(std::wstring& ParamA, std::wstring& ParamB) {
    
#if VERSIONWIN
    UUID uuid;
    RPC_WSTR flagPtr;
    if(UuidCreate(&uuid) == RPC_S_OK)
    {
        if(UuidToString(&uuid, &flagPtr) == RPC_S_OK)
        {
            ParamA = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
            RpcStringFree(&flagPtr);
            if(UuidCreate(&uuid) == RPC_S_OK)
            {
                if(UuidToString(&uuid, &flagPtr) == RPC_S_OK)
                {
                    ParamB = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
                    RpcStringFree(&flagPtr);
                }
            }
        }
    }
#endif
}

#if VERSIONWIN
void convert_xlsx_to_csv_ex(PA_PluginParameters params) {

	/*
	convert xlsx to csv(&T;&Y;&T;&T;&T;&T)
	*/

	PackagePtr pParams = (PackagePtr)params->fParameters;

	C_TEXT Param1_path;
	ARRAY_TEXT Param2_sheets;
	C_TEXT Param3_password;

	C_TEXT Param4_folder;
	C_TEXT Param5_field_delimiter;
	C_TEXT Param6_record_delimiter;

	Param4_folder.fromParamAtIndex(pParams, 4);
	Param5_field_delimiter.fromParamAtIndex(pParams, 5);
	Param6_record_delimiter.fromParamAtIndex(pParams, 6);

	Param1_path.fromParamAtIndex(pParams, 1);
	Param2_sheets.fromParamAtIndex(pParams, 2);
	Param3_password.fromParamAtIndex(pParams, 3);

	xlint_filepath_t xlnt_path;
	xlint_password_t xlnt_password;

	get_xlnt_path(Param1_path, xlnt_path);
	get_xlnt_password(Param3_password, xlnt_password);

    std::wstring caller_event_name;
    std::wstring callee_event_name;
    
    generate_uuid_pair(caller_event_name, callee_event_name);
    
	HANDLE event_caller = create_event_for_caller(caller_event_name);

	if (event_caller)
	{
		HANDLE fmIn = createFmIn(xlnt_path, xlnt_password, caller_event_name, callee_event_name);

		if (fmIn)
		{

			HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
				1024*1024*500 /* stack size:default */,
				open_xlsx_in_thread,
				NULL /* arguments */,
				0 /* init flags:execute immediately */,
				NULL /* thread id */);

			if (h)
			{
				xlnt::workbook *wb = waitForEvent(h, event_caller, callee_event_name);

                if(wb) {
                    delete wb;
                    wb = NULL;
                }
				CloseHandle(h);
			}//h

			CloseHandle(fmIn);
		}
		CloseHandle(event_caller);
	}


	xlnt::workbook *wb = open_xlsx(xlnt_path, xlnt_password);

	xlint_filepath_t folder_path;

	get_xlnt_path(Param4_folder, folder_path);

	create_folder((path_t *)folder_path.c_str());

	if (folder_path.length() != 0) {
#if VERSIONMAC
		if (folder_path.at(folder_path.size() - 1) != '/') folder_path += '/';
#else
		if (folder_path.at(folder_path.size() - 1) != L'\\') folder_path += L'\\';
#endif
	}

	CUTF8String _fdelimit;

	if (Param5_field_delimiter.getUTF16Length() == 0) {
		_fdelimit = CUTF8String((const uint8_t *)",");
	}
	else {
		Param5_field_delimiter.copyUTF8String(&_fdelimit);

	}

	CUTF8String _rdelimit;

	if (Param6_record_delimiter.getUTF16Length() == 0) {
		_rdelimit = CUTF8String((const uint8_t *)"\r\n");
	}
	else {
		Param6_record_delimiter.copyUTF8String(&_rdelimit);

	}

	const char *fdelimit = (const char *)_fdelimit.c_str();
	size_t fdelimit_len = _fdelimit.length();

	const char *rdelimit = (const char *)_rdelimit.c_str();
	size_t rdelimit_len = _rdelimit.length();

	if (Param2_sheets.getSize() == 0) {
		Param2_sheets.setSize(1);
		std::vector<std::string> sheet_titles = wb->sheet_titles();

		for (size_t i = 0; i < sheet_titles.size(); ++i)
		{
			std::string sheet_title = sheet_titles[i];
			Param2_sheets.appendUTF8String((const uint8_t *)sheet_title.c_str(), (uint32_t)sheet_title.length());
		}
	}

	for (int i = 1; i <= Param2_sheets.getSize(); ++i) {

		xlint_filepath_t file_path;
		std::string sheet_name;

		CUTF8String _u8;
		Param2_sheets.copyUTF8StringAtIndex(&_u8, i);
		sheet_name = std::string((const char *)_u8.c_str(), _u8.length());

#if VERSIONWIN
		CUTF16String _u16;
		Param2_sheets.copyUTF16StringAtIndex(&_u16, i);
		file_path = folder_path + std::wstring((const wchar_t *)_u16.c_str(), _u16.length());
		file_path += L".csv";
#else
		file_path = folder_path + sheet_name;
		file_path += ".csv";
#endif
		if (sheet_name.length()) {
			if (wb->contains(sheet_name)) {
				FILE *f = create_csv(file_path);

				if (f) {
					xlnt::worksheet ws = wb->sheet_by_title(sheet_name);

					time_t startTime = time(0);

					bool record_delimit = false;
					for (auto row : ws.rows(false))
					{
						time_t now = time(0);
						time_t elapsedTime = abs(startTime - now);

						if (elapsedTime > 0)
						{
							startTime = now;
							PA_YieldAbsolute();
						}

						if (record_delimit) {
							fwrite(rdelimit, rdelimit_len, sizeof(char), f);
						}

						bool field_delimit = false;
						for (auto cell : row)
						{
							if (field_delimit) {
								fwrite(fdelimit, fdelimit_len, sizeof(char), f);
							}

							std::string cell_value = cell.to_string();
							fwrite(cell_value.c_str(), cell_value.size(), sizeof(char), f);
							field_delimit = true;
						}
						record_delimit = true;
					}
					fclose(f);
				}
			}
		}
	}

	delete wb;
}
#endif

/*
 v1:standard c++ example using xlnt (out of memory with large sheets on windows)
 */

void convert_xlsx_to_csv(PA_PluginParameters params) {
    
    /*
     convert xlsx to csv(&T;&Y;&T;&T;&T;&T)
     */
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_path;
    ARRAY_TEXT Param2_sheets;
    C_TEXT Param3_password;
    
    C_TEXT Param4_folder;
    C_TEXT Param5_field_delimiter;
    C_TEXT Param6_record_delimiter;
    
    Param4_folder.fromParamAtIndex(pParams, 4);
    Param5_field_delimiter.fromParamAtIndex(pParams, 5);
    Param6_record_delimiter.fromParamAtIndex(pParams, 6);
    
    Param1_path.fromParamAtIndex(pParams, 1);
    Param2_sheets.fromParamAtIndex(pParams, 2);
    Param3_password.fromParamAtIndex(pParams, 3);
    
    xlint_filepath_t xlnt_path;
    xlint_password_t xlnt_password;
    
    get_xlnt_path(Param1_path, xlnt_path);
    get_xlnt_password(Param3_password, xlnt_password);
    
    xlnt::workbook wb;
    
    BOOL success = FALSE;
    
    try {
        
        if (xlnt_password.length())
        {
            wb.load(xlnt_path, xlnt_password);
        }
        else
        {
            wb.load(xlnt_path);
        }
        
        success = TRUE;
        
    } catch (std::exception e) {
        
    }
    
    if(success) {
        
        xlint_filepath_t folder_path;
        
        get_xlnt_path(Param4_folder, folder_path);
        
        create_folder((path_t *)folder_path.c_str());
        
        if(folder_path.length() != 0) {
#if VERSIONMAC
            if(folder_path.at(folder_path.size() - 1) !=   '/') folder_path +=   '/';
#else
            if(folder_path.at(folder_path.size() - 1) != L'\\') folder_path += L'\\';
#endif
        }
        
        CUTF8String _fdelimit;
        
        if(Param5_field_delimiter.getUTF16Length() == 0) {
            _fdelimit = CUTF8String((const uint8_t *)",");
        }else{
            Param5_field_delimiter.copyUTF8String(&_fdelimit);
            
        }
        
        CUTF8String _rdelimit;
        
        if(Param6_record_delimiter.getUTF16Length() == 0) {
            _rdelimit = CUTF8String((const uint8_t *)"\r\n");
        }else{
            Param6_record_delimiter.copyUTF8String(&_rdelimit);
            
        }
        
        const char *fdelimit = (const char *)_fdelimit.c_str();
        size_t fdelimit_len = _fdelimit.length();
        
        const char *rdelimit = (const char *)_rdelimit.c_str();
        size_t rdelimit_len = _rdelimit.length();
        
        BOOL real_all_sheets = TRUE;
        
        for (int i = 0; i <= Param2_sheets.getSize(); ++i) {
            CUTF16String _u16;
            Param2_sheets.copyUTF16StringAtIndex(&_u16, i);
            if(_u16.length()) {
                real_all_sheets = FALSE;
                break;
            }
        }

        if (real_all_sheets) {
            Param2_sheets.setSize(1);
            std::vector<std::string> sheet_titles = wb.sheet_titles();
            
            for (size_t i = 0; i < sheet_titles.size(); ++i)
            {
                std::string sheet_title = sheet_titles[i];
                Param2_sheets.appendUTF8String((const uint8_t *)sheet_title.c_str(), (uint32_t)sheet_title.length());
            }
        }
        
        for(int i = 1; i <= Param2_sheets.getSize();++i) {
            
            xlint_filepath_t file_path;
            std::string sheet_name;
            
            CUTF8String _u8;
            Param2_sheets.copyUTF8StringAtIndex(&_u8, i);
            sheet_name = std::string((const char *)_u8.c_str(), _u8.length());
            
#if VERSIONWIN
            CUTF16String _u16;
            Param2_sheets.copyUTF16StringAtIndex(&_u16, i);
            file_path = folder_path + std::wstring((const wchar_t *)_u16.c_str(), _u16.length());
            file_path += L".csv";
#else
            file_path = folder_path + sheet_name;
            file_path += ".csv";
#endif
            if(sheet_name.length()){
                if(wb.contains(sheet_name)) {
                    FILE *f = create_csv(file_path);
                    
                    if(f) {
                        xlnt::worksheet ws = wb.sheet_by_title(sheet_name);
                        
                        time_t startTime = time(0);
                        
                        bool record_delimit = false;
                        for (auto row : ws.rows(false))
                        {
                            time_t now = time(0);
                            time_t elapsedTime = abs(startTime - now);
                            
                            if(elapsedTime > 0)
                            {
                                startTime = now;
                                PA_YieldAbsolute();
                            }
                            
                            if(record_delimit){
                                fwrite(rdelimit, rdelimit_len, sizeof(char), f);
                            }
                            
                            bool field_delimit = false;
                            for (auto cell : row)
                            {
                                if(field_delimit){
                                    fwrite(fdelimit, fdelimit_len, sizeof(char), f);
                                }
                                
                                std::string cell_value = cell.to_string();
                                fwrite(cell_value.c_str(), cell_value.size(), sizeof(char), f);
                                field_delimit = true;
                            }
                            record_delimit = true;
                        }
                        fclose(f);
                    }
                }
            }
        }
    }
}

/*
 v2:standard c++ example using xlsxio
*/

void convert_xlsx_to_csv_v2(PA_PluginParameters params) {
    
    /*
     convert xlsx to csv(&T;&Y;&T;&T;&T;&T)
     */
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_path;
    ARRAY_TEXT Param2_sheets;
    C_TEXT Param3_password;
    
    C_TEXT Param4_folder;
    C_TEXT Param5_field_delimiter;
    C_TEXT Param6_record_delimiter;
    
    C_LONGINT Param7_encoding;
    
    Param4_folder.fromParamAtIndex(pParams, 4);
    Param5_field_delimiter.fromParamAtIndex(pParams, 5);
    Param6_record_delimiter.fromParamAtIndex(pParams, 6);
    Param7_encoding.fromParamAtIndex(pParams, 7);
    
    Param1_path.fromParamAtIndex(pParams, 1);
    Param2_sheets.fromParamAtIndex(pParams, 2);
    Param3_password.fromParamAtIndex(pParams, 3);
    
    bool with_utf8_bom = true;
    bool use_shift_jis = false;
    
    switch (Param7_encoding.getIntValue()) {
        case 1:
            with_utf8_bom = false;
            break;
        case 2:
            use_shift_jis = true;
            with_utf8_bom = false;
            break;
        default:
            break;
    }
    
    xlint_filepath_t xlnt_path;
    xlint_password_t xlnt_password;
    
    get_xlnt_path(Param1_path, xlnt_path);
    get_xlnt_password(Param3_password, xlnt_password);
    
    xlint_filepath_t folder_path;
    
    get_xlnt_path(Param4_folder, folder_path);
    
    create_folder((path_t *)folder_path.c_str());
    
    if(folder_path.length() != 0) {
#if VERSIONMAC
        if(folder_path.at(folder_path.size() - 1) !=   '/') folder_path +=   '/';
#else
        if(folder_path.at(folder_path.size() - 1) != L'\\') folder_path += L'\\';
#endif
    }
    
    CUTF8String _fdelimit;
    
    if(Param5_field_delimiter.getUTF16Length() == 0) {
        _fdelimit = CUTF8String((const uint8_t *)",");
    }else{
        Param5_field_delimiter.copyUTF8String(&_fdelimit);
        
    }
    
    CUTF8String _rdelimit;
    
    if(Param6_record_delimiter.getUTF16Length() == 0) {
        _rdelimit = CUTF8String((const uint8_t *)"\r\n");
    }else{
        Param6_record_delimiter.copyUTF8String(&_rdelimit);
        
    }
    
    const char *fdelimit = (const char *)_fdelimit.c_str();
    size_t fdelimit_len = _fdelimit.length();
    
    const char *rdelimit = (const char *)_rdelimit.c_str();
    size_t rdelimit_len = _rdelimit.length();
    
    BOOL real_all_sheets = TRUE;
    
    for (int i = 0; i <= Param2_sheets.getSize(); ++i) {
        CUTF16String _u16;
        Param2_sheets.copyUTF16StringAtIndex(&_u16, i);
        if(_u16.length()) {
            real_all_sheets = FALSE;
            break;
        }
    }

#if VERSIONWIN
	CUTF8String _path;
	Param1_path.copyPath(&_path);
	xlsxioreader xlsxioread = xlsxioread_open((const char *)_path.c_str());
#else
	xlsxioreader xlsxioread = xlsxioread_open(xlnt_path.c_str());
#endif

    if (xlsxioread) {
        if (real_all_sheets) {
            xlsxioreadersheetlist sheetlist = xlsxioread_sheetlist_open(xlsxioread);
            if (sheetlist) {
                const char *sheetname;
                while ((sheetname = xlsxioread_sheetlist_next(sheetlist)) != NULL) {
                    Param2_sheets.appendUTF8String((const uint8_t *)sheetname, (uint32_t)strlen(sheetname));
                }
                xlsxioread_sheetlist_close(sheetlist);
            }
        }
        
        for(int i = 1; i <= Param2_sheets.getSize();++i) {
            
            xlint_filepath_t file_path;
            std::string sheet_name;
            
            CUTF8String _u8;
            Param2_sheets.copyUTF8StringAtIndex(&_u8, i);
            sheet_name = std::string((const char *)_u8.c_str(), _u8.length());
            
			if (sheet_name.length()) {
				xlsxioreadersheet sheet = xlsxioread_sheet_open(xlsxioread, sheet_name.c_str(), XLSXIOREAD_SKIP_NONE);

				if (sheet) {

#if VERSIONWIN
					CUTF16String _u16;
					Param2_sheets.copyUTF16StringAtIndex(&_u16, i);
					file_path = folder_path + std::wstring((const wchar_t *)_u16.c_str(), _u16.length());
					file_path += L".csv";
#else
					file_path = folder_path + sheet_name;
					file_path += ".csv";
#endif

                    char bom[3];
                    bom[0] = 0xEF;
                    bom[1] = 0xBB;
                    bom[2] = 0xBF;
                    
					FILE *f = create_csv(file_path);
					if (f) {

                        if(with_utf8_bom) {
                            fwrite(bom, 3, sizeof(char), f);
                        }

						time_t startTime = time(0);
						bool record_delimit = false;

						while (xlsxioread_sheet_next_row(sheet))
						{
							time_t now = time(0);
							time_t elapsedTime = abs(startTime - now);

							if (elapsedTime > 0)
							{
								startTime = now;
								PA_YieldAbsolute();
							}

							if (record_delimit) {
								fwrite(rdelimit, rdelimit_len, sizeof(char), f);
							}

							bool field_delimit = false;

							char *value;
							while ((value = xlsxioread_sheet_next_cell(sheet)) != NULL)
							{
								if (field_delimit) {
									fwrite(fdelimit, fdelimit_len, sizeof(char), f);
								}

								std::string cell_value = std::string(value);//utf-8
                                
                                if(use_shift_jis) {
                                    
                                    
                                    PA_long32 dataSize = (PA_long32)((cell_value.length() * sizeof(char) * 2)+ sizeof(char));
                                    std::vector<char> buf(dataSize);
                                    
                                    PA_long32 len = PA_ConvertCharsetToCharset((char *)cell_value.c_str(),
                                    (PA_long32)cell_value.length() * sizeof(char),
                                    eVTC_UTF_8,
                                    (char *)&buf[0],
                                    dataSize,
                                    eVTC_SHIFT_JIS);
                                    
                                    cell_value = std::string((char *)&buf[0], len);
                                    
                                }
                                
								fwrite(cell_value.c_str(), cell_value.size(), sizeof(char), f);
								field_delimit = true;

							}
							record_delimit = true;
						}
						xlsxioread_sheet_close(sheet);

						fclose(f);
					}
				}
			}

        }

        xlsxioread_close(xlsxioread);
    }
}
