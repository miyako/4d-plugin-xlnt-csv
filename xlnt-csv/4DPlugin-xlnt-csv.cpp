/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-xlnt-csv.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : xlnt-csv
 #	author : miyako
 #	2020/10/02
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-xlnt-csv.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- xlnt-csv
            
			case 1 :
				convert_xlsx_to_csv(params);
				break;
			case 2 :
				get_xlsx_sheets(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
typedef std::string  xlint_filepath_t;
#else
typedef std::wstring xlint_filepath_t;
#endif

typedef std::string  xlint_password_t;

static void get_xlnt_path(C_TEXT& path, xlint_filepath_t& xlnt_path) {
    
#if VERSIONMAC
        CUTF8String _path;
        path.copyPath(&_path);
        xlnt_path = std::string ((const char    *)_path.c_str(), _path.length());
#else
        xlnt_path = std::wstring((const wchar_t *)path.getUTF16StringPtr(), path.getUTF16Length());
#endif
}

static void get_xlnt_password(C_TEXT& password, xlint_password_t& xlnt_password) {
 
    CUTF8String _password;
    password.copyUTF8String(&_password);
    xlnt_password = std::string((const char *)_password.c_str(), _password.length());
    
}

static void open_xlsx(xlnt::workbook& wb,
                      C_TEXT& path,
                      xlint_filepath_t& xlnt_path,
                      C_TEXT& password,
                      xlint_password_t& xlnt_password) {
    
    get_xlnt_path(path, xlnt_path);
    get_xlnt_password(password, xlnt_password);
    
    if(xlnt_password.length())
    {
        wb.load(xlnt_path, xlnt_password);
    }else
    {
        wb.load(xlnt_path);
    }
    
}

void get_xlsx_sheets(PA_PluginParameters params) {

    /*
         get xlsx sheets(&T;&Y;&T)
     */
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1_path;
    C_TEXT Param3_password;
    
    Param1_path.fromParamAtIndex(pParams, 1);
    Param3_password.fromParamAtIndex(pParams, 3);
    
    xlint_filepath_t xlnt_path;
    xlint_password_t xlnt_password;

    xlnt::workbook wb;
    
    open_xlsx(wb, Param1_path, xlnt_path, Param3_password, xlnt_password);

    ARRAY_TEXT Param2_sheets;
    
    Param2_sheets.setSize(1);
    
    std::vector<std::string> sheet_titles = wb.sheet_titles();
    
    for(size_t i = 0; i < sheet_titles.size(); ++i)
    {
        std::string sheet_title = sheet_titles[i];
        Param2_sheets.appendUTF8String((const uint8_t *)sheet_title.c_str(), (uint32_t)sheet_title.length());
    }
    
    Param2_sheets.toParamAtIndex(pParams, 2);
    
}

#if VERSIONMAC
#define CPathString CUTF8String
#define CPathOpen fopen
#define CPathAppend "ab"
#define CPathCreate "wb"
#define CPathRead "rb"
#else
#include <Shlobj.h>
#define CPathString CUTF16String
#define CPathOpen _wfopen
#define CPathAppend L"ab"
#define CPathCreate L"wb"
#define CPathRead L"rb"
#endif

#if VERSIONMAC
typedef std::string absolute_path_t;
#define folder_separator '/'
#else
typedef std::wstring absolute_path_t;
#define folder_separator L'\\'
#endif

#if VERSIONMAC
typedef char path_t;
#else
typedef wchar_t path_t;
#endif

bool create_folder(path_t *absolute_path) {
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
    
    return success;
}

void create_parent_folder(path_t *absolute_path) {
    
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder((path_t *)folderPath.c_str());
    [filePath release];
#else
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder((path_t *)folderPath.c_str());
#endif
}

static FILE *create_csv(ARRAY_TEXT& sheets,
                        uint32_t i,
                        xlint_filepath_t& folder_path,
                        std::string& sheet_name) {
    
    CUTF8String _sheet_name;
    sheets.copyUTF8StringAtIndex(&_sheet_name, i);
    
    sheet_name = std::string((const char *)_sheet_name.c_str(), (size_t)_sheet_name.length());
    
    xlint_filepath_t file_path;
    
    #if VERSIONWIN
        CUTF16String _u16;
        sheets.copyUTF16StringAtIndex(&_u16, i);
        file_path = folder_path + std::wstring((const wchar_t *)_u16.c_str(), _u16.length());;
    #else
        file_path = folder_path +  sheet_name;
    #endif
    
    return CPathOpen (file_path.c_str(), CPathCreate);
}

void convert_xlsx_to_csv(PA_PluginParameters params) {

    /*
         convert xlsx to csv(&T;&Y;&T;&T;&T;&T)
     */
    
    PackagePtr pParams = (PackagePtr)params->fParameters;

    C_TEXT Param1_path;
    ARRAY_TEXT Param2_sheets;
    C_TEXT Param3_password;

    C_TEXT Param4_folder;
    C_TEXT Param5_field_delimiter;
    C_TEXT Param6_record_delimiter;
    
    Param4_folder.fromParamAtIndex(pParams, 4);
    Param5_field_delimiter.fromParamAtIndex(pParams, 5);
    Param6_record_delimiter.fromParamAtIndex(pParams, 6);
    
    Param1_path.fromParamAtIndex(pParams, 1);
    Param2_sheets.fromParamAtIndex(pParams, 2);
    Param3_password.fromParamAtIndex(pParams, 3);

    xlint_filepath_t xlnt_path;
	xlint_password_t xlnt_password;

    xlnt::workbook wb;

    open_xlsx(wb, Param1_path, xlnt_path, Param3_password, xlnt_password);
    
    xlint_filepath_t folder_path;
    
    get_xlnt_path(Param4_folder, folder_path);
        
    create_folder((path_t *)folder_path.c_str());
    
    if(folder_path.length() != 0) {
        #if VERSIONMAC
        if(folder_path.at(folder_path.size() - 1) !=   '/') folder_path +=   '/';
        #else
        if(folder_path.at(folder_path.size() - 1) != L'\\') folder_path += L'\\';
        #endif
    }
    
    CUTF8String _fdelimit;
    
    if(Param5_field_delimiter.getUTF16Length() == 0) {
        _fdelimit = CUTF8String((const uint8_t *)",");
    }else{
        Param5_field_delimiter.copyUTF8String(&_fdelimit);
        
    }
    
    CUTF8String _rdelimit;
    
    if(Param6_record_delimiter.getUTF16Length() == 0) {
        _rdelimit = CUTF8String((const uint8_t *)"\r\n");
    }else{
        Param6_record_delimiter.copyUTF8String(&_rdelimit);
        
    }
        
    const char *fdelimit = (const char *)_fdelimit.c_str();
    size_t fdelimit_len = _fdelimit.length();
    
    const char *rdelimit = (const char *)_rdelimit.c_str();
    size_t rdelimit_len = _rdelimit.length();
    
    for(int i = 0; i < Param2_sheets.getSize();++i) {

        std::string sheet_name;
        
        FILE *f = create_csv(Param2_sheets, i, folder_path, sheet_name);
        
        if(f)
        {
            xlnt::worksheet ws = wb.sheet_by_title(sheet_name);
            
            time_t startTime = time(0);
            
            bool record_delimit = false;
            for (auto row : ws.rows(false))
            {
                time_t now = time(0);
                time_t elapsedTime = abs(startTime - now);
                
                if(elapsedTime > 0)
                {
                    startTime = now;
                    PA_YieldAbsolute();
                }
                
                if(record_delimit){
                    fwrite(rdelimit, rdelimit_len, sizeof(char), f);
                }
                
                bool field_delimit = false;
                for (auto cell : row)
                {
                    if(field_delimit){
                        fwrite(fdelimit, fdelimit_len, sizeof(char), f);
                    }

                    std::string cell_value = cell.to_string();
                    fwrite(cell_value.c_str(), cell_value.size(), sizeof(char), f);
                    field_delimit = true;
                }
                record_delimit = true;
            }
            fclose(f);
        }
        
    }
    
}
